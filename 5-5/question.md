# 今日面试问题汇总

## 一、Redis 相关问题

1. **AOF 重写机制**

   * 为什么在使用 AOF 持久化时，Redis 选择通过 `fork()` 子进程来重写 AOF 文件，而不是开启一个后台线程？
   * 在设计上，重写 AOF 本质上只是只读操作进行记录，使用线程进行操作是否更轻量、快速？为什么不可行？

2. **RDB 快照机制**

   * RDB 快照是如何实现的？
   * RDB 快照的优缺点是什么？
   * 启动流程：加载 RDB 后再 replay AOF，如何兼顾启动速度与数据安全？

3. **持久化方案对比**

   * AOF 与 RDB 的设计权衡、重写机制、触发条件。
   * 混合使用 AOF + RDB 在生产环境中的常见实践。

4. **Redis 核心特性与原理**（部分回顾）

   * 内存存储与多种数据结构（String、List、Hash、Set、Sorted-Set）。
   * 单线程模型与命令执行流程（RESP 协议解析、Dispatcher、原子性保证）。
   * 过期与驱逐策略（TTL 的惰性删除与定期删除；`volatile-lru`、`allkeys-lfu` 等回收策略）。
   * 主从复制与高可用（PSYNC 协议、Sentinel 自动故障切换、Cluster 插槽迁移）。

## 二、Go 语言相关问题

1. **内存分配关键字**

   * `new` 与 `make` 的区别与使用场景。
   * `new(T)` 与 `&T{}` 在分配、逃逸分析和可读性方面的异同。

2. **Go 内建 map 实现**

   * map 扩容机制：桶 (bucket) 结构、负载因子、何时触发扩容、渐进重哈希原理。
   * Go 内建 map 的优缺点及优化点。

3. **高级哈希表实现**

   * Swiss Table（Google Abseil/Folly 的 flat\_hash\_map 等）与 Go 内建 map 的存储布局、查找/插入机制对比。
   * 性能差异与适用场景。

4. **并发安全的 Map**

   * **`sync.Map`**：双层数据结构（只读区 + 脏区）、无锁读、脏区合并、优缺点、使用场景与优化点。
   * **分片锁 (Sharded Map)**：哈希分片 + `sync.RWMutex`、锁粒度、遍历与回调、优缺点、适用场景。
   * **Copy-On-Write (COW) Map**：原子快照 + 写时拷贝、读无锁、写 O(N) 拷贝成本、优缺点、适用场景。

5. **细节实现与优化**

   * 在分片锁基础上引入 COW，让读无锁；设计思路与关键代码修改点。
   * Hash 函数选择与缓存、分片数量调优。
   * 批量操作、遍历方式 (`IterCb`、`IterBuffered`、`Items`) 的实现与性能考量。

6. **基准测试**

   * 对比 `sync.Map` 与 `orcaman/concurrent-map` 的读写性能：基准测试设计、运行命令、结果分析。
   * 读写混合负载、延迟分布 (P50/P99)、内存分配 (`allocs/op`) 等指标的比较。

---

