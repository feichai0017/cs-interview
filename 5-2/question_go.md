# 🧠 Go 语言八股文题库总结（含底层原理）

本文件汇总了关于 Go 编程语言的高频面试八股题，涵盖基础语法、协程调度、内存模型、垃圾回收和并发安全等关键知识点，适用于中高级开发工程师面试准备。

---

## ✅ 第一组：Go 基础原理

### 1. Go 的切片底层结构是什么？扩容策略如何？

- 切片是一个结构体，包含：指针、长度、容量；
- 底层是数组，扩容规则：
  - 小于 1024 时一般为 2 倍扩容；
  - 大于等于 1024 后增长为 1.25 倍；
- 扩容会重新分配新数组并拷贝旧数据。

---

### 2. defer 的执行顺序和作用是什么？有何性能影响？

- 执行顺序为后进先出（LIFO）；
- 用于资源释放（如锁、文件等）；
- 在高频调用路径下略有性能开销，因为每次 `defer` 会创建闭包；
- Go 编译器对简单 defer 场景做了优化（例如返回前立即调用）。

---

### 3. goroutine 和线程的区别？调度方式是什么？

- goroutine 是用户态的轻量线程；
- 初始栈仅 2KB，支持自动增长；
- Go 使用 GMP 模型调度：
  - G：goroutine（任务）
  - M：machine（OS 线程）
  - P：processor（调度上下文，持有 G 队列）

---

### 4. map 是并发安全的吗？怎么处理？

- 原生 `map` 不是并发安全；
- 并发访问会 panic；
- 解决方式：
  1. `sync.Mutex` 保护 map；
  2. 使用 `sync.Map`（适合读多写少）；
  3. 自己实现分段锁 map。

---

### 5. new 和 make 的区别？

| 特性     | new              | make                                 |
|----------|------------------|--------------------------------------|
| 返回     | 指针             | 初始化好的对象（slice/map/channel） |
| 分配类型 | 所有类型         | 仅限引用类型                        |
| 用途     | 分配 + 零值初始化 | 初始化可直接使用的数据结构          |

---

## ✅ 第二组：Go 协程与调度器原理

### 6. channel 的作用和实现机制？

- goroutine 间通信机制；
- 底层是一个 MPSC 环形队列；
- 使用 sendq / recvq 等待队列管理阻塞 goroutine；
- 调度器通过 park/unpark 实现挂起与唤醒。

---

### 7. select 的作用？

- 多路复用等待多个 channel；
- 会公平随机选中一个可用分支；
- 支持 `default` 分支实现非阻塞；

---

### 8. sync.Mutex vs sync.RWMutex？

- Mutex：独占锁，读写互斥；
- RWMutex：
  - `RLock()` 可多个读；
  - `Lock()` 写互斥所有访问；
- RWMutex 适合读多写少场景。

---

### 9. sync.WaitGroup 是怎么工作的？

- `Add(n)` 增加等待 goroutine 数量；
- 每个 goroutine `Done()`；
- 主线程 `Wait()` 阻塞直到计数归零；
- 用于等待一组 goroutine 执行完成。

---

### 10. 如何安全退出 goroutine？

- 推荐使用 `context.Context` 控制退出；
- 或使用 `done chan struct{}` 信号通道；
- goroutine 中使用 `select` 监听退出信号。

---

## ✅ 第三组：Go 底层原理

### 11. Go 协程调度：GMP 模型

- G：goroutine（任务）
- M：machine（线程）
- P：processor（调度器，持有本地 G 队列）
- G 通过 P 被调度到 M 上运行；
- 支持 work stealing（偷取其他 P 的 G）做负载均衡。

---

### 12. 为什么要有 P？为什么不直接 G ↔ M？

- 避免直接绑定导致上下文频繁切换；
- P 拥有调度权和执行上下文，避免全局锁竞争；
- 实现本地队列 + work stealing + 内存复用（如 defer 栈缓存）；

---

### 13. 什么是 work stealing？

- 某个 P 的 G 队列为空时，会从其他 P 偷 G；
- 实现调度负载均衡；
- 通常偷一半，降低迁移成本；
- 与全局 G 队列配合形成三级调度队列。

---

### 14. goroutine 泄漏是什么？如何避免？

- goroutine 阻塞不能退出但程序仍在运行，称为泄漏；
- 常见原因：
  - 未读取的 channel
  - select 无退出分支
  - for 无限循环
- 解决方案：
  - 使用 `context` 控制生命周期；
  - 使用 `runtime.NumGoroutine()` 和 `pprof` 排查。

---

### 15. Go 的逃逸分析机制？

- 编译期分析变量作用域；
- 判断变量是否逃出函数栈帧；
- 逃逸 → 分配在堆上（需 GC 回收）；
- 不逃逸 → 分配在栈上，函数结束自动回收；
- 使用 `go build -gcflags "-m"` 查看。

---

### 16. Go 的垃圾回收机制和三色标记法？

- 使用 **三色标记清除 GC**：
  - 白色：未访问 → 候选垃圾
  - 灰色：已访问但引用未处理
  - 黑色：已访问且引用已处理完
- 使用 **混合写屏障** 防止并发 GC 中黑色引用白色；
- 清除阶段回收所有白色对象；
- 支持低暂停时间、并发标记和清扫；
- Go1.18 后 GC 优化暂停时间 <1ms，并提升触发预测机制。